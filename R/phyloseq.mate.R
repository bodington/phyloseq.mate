#' Cluster ASVs in a sequence table into OTUs
#
#' @description
#' Takes the ASV sequence table generated by DADA2 (seqtab) or phyloseq and
#' clusters OTUs.
#'
#' @details Filler
#' @param seqtab A sequence table eg. generated by dada2.
#' @param similarity OTU clustering distance (%).
#' @param nproc Number of processors.
#' @return A clustered sequence table
#' @importFrom Biostrings DNAStringSet
#' @importFrom DECIPHER AlignSeqs
#' @importFrom DECIPHER TreeLine
#' @examples
#' \dontrun{
#' clustered.seqtab <- cluster_asv_dada2(asv.seqtab)
#' }
#' @export
cluster_asv_dada2 <- function(seqtab,
                              similarity = 99,
                              nproc = 4) {
  asv_sequences <- colnames(seqtab)
  dna <- Biostrings::DNAStringSet(asv_sequences)
  aln <- DECIPHER::AlignSeqs(dna, processors = nproc)
  d <- DECIPHER::DistanceMatrix(aln, processors = nproc)
  clusters <- DECIPHER::TreeLine(
    myDistMatrix = d,
    method = "complete",
    cutoff = 1 - similarity / 100,
    type = "clusters",
    processors = nproc
  )
  clusters <- clusters %>%
    add_column(sequence = asv_sequences)
  seqtab_clustered <- seqtab %>%
    t %>%
    rowsum(clusters$cluster) %>%
    t
  return(seqtab_clustered)
}


#' Cluster ASVs in a phyloseq object into OTUs
#'
#' @description
#' Takes a phyloseq object with sequence data and clusters ASVs to OTUs
#'
#' @param ps A phyloseq object
#' @param similarity OTU clustering distance (%)
#' @param nproc Number of processors
#'
#' @details Filler
#' @return A phyloseq object with OTUs at a set similarity
#' @importFrom phyloseq refseq
#' @importFrom DECIPHER AlignSeqs
#' @importFrom DECIPHER TreeLine
#' @importFrom speedyseq merge_taxa_vec
#' @examples
#' \dontrun{
#' clustered.seqtab <- cluster_asv_dada2(asv.seqtab)
#' }
#' @export
cluster_asv_phyloseq <- function(ps,
                                 similarity = 99,
                                 nproc = 4) {
  dna <- refseq(ps)
  aln <- DECIPHER::AlignSeqs(dna, processors = nproc)
  d <- DECIPHER::DistanceMatrix(aln, processors = nproc)
  clusters <- DECIPHER::TreeLine(
    myDistMatrix = d,
    method = "complete",
    cutoff = 1 - similarity / 100,
    type = "clusters",
    processors = nproc
  )
  ps <-
    speedyseq::merge_taxa_vec(ps, group = clusters$cluster, tax_adjust = 2)
  taxa_names(ps) <- paste0("OTU", seq(ntaxa(ps)))
  return(ps)
}

#' Classify a phyloseq object with dada2
#'
#' @description
#' Assigns taxonomy to a phyloseq object using dada2 assignTaxonomy
#'
#' @param ps A phyloseq object
#' @details The sequence table is assigned taxonomy using assignTaxonomy with
#' @details the greengenes or GTDB training set. (Ranks: D;P;C;O;F;G;S)
#' @return A phyloseq object with new tax assignments.
#' @import phyloseq
#' @importFrom dada2 assignTaxonomy
#' @examples
#' \dontrun{
#' tax_table(phyloseq_project) <- phyloseq_tax_dada2(phyloseq_project, tax_file)
#' }
#' @export
phyloseq_tax_dada2 <- function(ps,
                               tax_file) {
  taxid <- assignTaxonomy(
    seqs = refseq(ps),
    refFasta = tax_file,
    minBoot = 80,
    multithread = TRUE
  )
  rownames(taxid) <- names(rownames(taxid))
  tax_table(ps) <- tax_table(taxid)
  return(ps)
}

#' Classify a phyloseq object with decipher
#'
#' @description
#' Assigns taxonomy to a phyloseq object using decipher, and returns the tax table
#'
#' @param ps A phyloseq object
#' @details The sequence table is assigned taxonomy using DECIPHER with the
#' @details greengenes or GTDB training set. (Ranks: D;P;C;O;F;G;S)
#' @return A phyloseq object with new tax assignments merged into the tax table.
#' @import phyloseq
#' @importFrom DECIPHER IdTaxa
#' @examples
#' \dontrun{
#' tax_table(phyloseq_project) <- phyloseq_decipher_tax(phyloseq_project, tax_file)
#' }
#' @export
phyloseq_tax_decipher <- function(ps,
                                  tax_file,
                                  nprocs = 8) {
  load(tax_file)
  dna <- refseq(ps)
  ids <- IdTaxa(dna,
    trainingSet,
    strand = "top",
    processors = nprocs,
    verbose = FALSE
  )
  ranks <- c("domain", "phylum", "class", "order", "family", "genus", "species")
  taxid <- t(
    sapply(
      ids,
      function(x) {
        m <- match(ranks, x$rank)
        taxa <- x$taxon[m]
        taxa[startsWith(taxa, "unclassified_")] <- NA
        taxa
      }
    )
  )
  colnames(taxid) <- ranks
  rownames(taxid) <- names(dna)
  ps <- merge_phyloseq(ps, tax_table(taxid))
  return(ps)
}

#' Cleanly merge (using sequence as ASV name) phyloseq objects in a list
#'
#' @description
#' Assigns taxonomy to a phyloseq object using decipher, and returns the tax
#' table
#'
#' @param ps_list A list of phyloseq objects
#' @details A list containing only phyloseq objects can be cleanly merged,
#' @details including identical ASVs where the ASV name differs in the objects.
#' @details ASV merging is done by sequence
#' @return A phyloseq object with all objects in the list merged
#' @import phyloseq
#' @examples
#' \dontrun{
#' merged_phyloseq <- phyloseq_clean_merge(list_of_phyloseq_objects)
#' }
#' @export
phyloseq_clean_merge <- function(phyloseq_list) {
  do.call(
    merge_phyloseq,
    lapply(
      phyloseq_list,
      function(x) {
        taxa_names(x) <- as.character(refseq(x), use.names = FALSE)
        return(x)
      }
    )
  )
}


#' Root Tree in phyloseq Object
#'
#' @description
#' Roots an unrooted tree in a phyloseq object
#'
#' @param ps A phyloseq object containing an unrooted tree
#' @details The tree is rooted by the longest terminal branch.
#' @return The same phyloseq object with a rooted tree
#' @importFrom ape Ntip
#' @importFrom magrittr %>%
#' @importFrom data.table data.table
#' @examples
#' \dontrun{
#' expt.rooted <- root_phyloseq_tree(expt.unrooted)
#' }
#' @export
phyloseq_root_tree <- function(ps) {
  tree.unrooted <- phy_tree(ps)
  # tablify parts of tree that we need.
  treeDT <-
    cbind(
      data.table(tree.unrooted$edge),
      data.table(length = tree.unrooted$edge.length)
    )[1:Ntip(tree.unrooted)] %>%
    cbind(data.table(id = tree.unrooted$tip.label))
  # Take the longest terminal branch as outgroup
  new.outgroup <- treeDT[which.max(length)]$id
  new.tree <- ape::root(tree.unrooted, outgroup = new.outgroup, resolve.root = TRUE)
  phy_tree(ps) <- new.tree
  return(ps)
}

#' Split Pseudomonadota
#'
#' @description
#' Splits Pseudomonadota into the Proteobacteria classes
#'
#' @param ps A phyloseq object
#' @details The tax table is returned with Pseudomonadota split into the
#' @details Proteobacteria classes
#' @return The same phyloseq object with Proteobacteria classes in the "Phylum"
#' @return column.
#' @import phyloseq
#' @examples
#' \dontrun{
#' phyloseq_object_proteo <- phyloseq_split_proteo(phyloseq_object)
#' }
#' @export
phyloseq_split_proteo <- function(ps) {
  plot.tax <- as.data.frame(
    ps@tax_table
  )
  plot.tax <- data.frame(
    lapply(
      plot.tax,
      as.character
    ),
    stringsAsFactors = FALSE
  )
  plot.tax$Phylum[plot.tax$Phylum == "Pseudomonadota"] <- plot.tax$Class[plot.tax$Phylum == "Pseudomonadota"]
  plot.tax[] <- lapply(plot.tax, factor)
  plot.tax.table <- tax_table(plot.tax)
  rownames(plot.tax.table) <- rownames(ps@tax_table)
  colnames(plot.tax.table) <- colnames(ps@tax_table)
  ps@tax_table <- plot.tax.table
  return(ps)
}

#' Export phyloseq object to dataset
#'
#' @description
#' Exports the sequence table and fasta file from a phyloseq object
#'
#' @param ps A phyloseq object
#' @param filePATH The path to write the files
#' @param filePREFIX The prefix for the output files
#' @param writeFASTA Write the fasta file
#' @param rename Rename the ASVs to ASV1, ASV2, etc.
#' @param useREFSEQ Use the refseq slot for sequence data
#' @details A sequence table and fasta file are written to the file path
#' @export
phyloseq_write_dataset <- function(ps,
                                    filePATH,
                                    filePREFIX,
                                    writeFASTA = TRUE,
                                    rename = FALSE,
                                    useREFSEQ = TRUE) {
  #pull seqs from refseq slot or extract from ASV ID for fasta format
  if (isTRUE(useREFSEQ)) {
    #from phyloseq refseq slot
    f.onames <- phyloseq::refseq(ps)
  } else {
    f.onames <- phyloseq::taxa_names(ps)
  }
  if (isTRUE(rename)) {
    phyloseq::taxa_names(ps) <-
      paste("ASV", 1:length(phyloseq::taxa_names(ps)), sep = "")
    names(f.onames) <- paste0(">", phyloseq::taxa_names(ps))
  } else {
    names(f.onames) <- paste0(">", phyloseq::taxa_names(ps))
  }
  #generate asv table formatted for biom generation
  asv.tab <- .format_asv_table(ps)
  suppressWarnings(asv.tab <- as.matrix(asv.tab))
  cb <- as.matrix(cbind(rownames(asv.tab), asv.tab))
  rcb <- as.matrix(rbind(colnames(cb), cb))
  rcb[1, 1] <- "#ASVID"
  rownames(rcb) <- NULL
  colnames(rcb) <- NULL
  #generate tax table formatted for biom generation
  tax.tab <- as.data.frame(phyloseq::tax_table(ps))
  tax.tab$taxonomy <-
    tidyr::unite(tax.tab, "out", c(colnames(tax.tab)), sep = ";")
  cbt <- as.matrix(cbind(rownames(tax.tab), tax.tab$taxonomy))
  rcbt <- as.matrix(rbind(c("#ASVID", "taxonomy"), cbt))
  rownames(cbt) <- NULL
  colnames(cbt) <- NULL
  #generate sampledf table formatted for biom generation
  samdf <- suppressWarnings(as.matrix(phyloseq::sample_data(ps)))
  cbs <- as.matrix(cbind(rownames(samdf), samdf))
  rcbs <- as.matrix(rbind(colnames(cbs), cbs))
  rcbs[1, 1] <- "#SampleID"
  rownames(rcbs) <- NULL
  colnames(rcbs) <- NULL
  #create output string
  if (isTRUE(writeFASTA)) {
    fa <- print(paste0(filePATH, filePREFIX, "_asv.fasta"))
  }
  otb <- print(paste0(filePATH, filePREFIX, "_asv_table.txt"))
  ttb <- print(paste0(filePATH, filePREFIX, "_asv_taxonomy.txt"))
  stb <- print(paste0(filePATH, filePREFIX, "_sample_data.txt"))
  #write output
  #ASV fasta
  if (isTRUE(writeFASTA)) {
    write.table(
      x = f.onames,
      file = fa,
      quote = FALSE,
      sep = "\n",
      col.names = FALSE
    )
  }
  #asv_tab
  write.table(
    x = rcb,
    file = otb,
    row.names = FALSE,
    col.names = FALSE,
    quote = FALSE,
    sep = "\t"
  )
  #tax.tab
  write.table(
    x = rcbt,
    file = ttb,
    row.names = FALSE,
    col.names = FALSE,
    quote = FALSE,
    sep = "\t"
  )
  #sampledf
  write.table(
    x = rcbs,
    file = stb,
    row.names = FALSE,
    col.names = FALSE,
    quote = FALSE,
    sep = "\t"
  )
  #return phyloseq object with taxa renamed to ASV1, etc., if desired
  if (isTRUE(rename)) {
    return(ps)
  }
}

#' Export phyloseq object to .biom file
#'
#' @description
#' Exports the sequence table and sequences from a phyloseq object
#' to a .biom file
#' @param ps A phyloseq object
#' @param filePATH The path to write the files
#' @param filePREFIX The prefix for the output files
#' @param writeFASTA Write the fasta file
#' @param rename Rename the ASVs to ASV1, ASV2, etc.
#' @param useREFSEQ Use the refseq slot for sequence data
#' @details A sequence table and fasta file are written to the file path
#' @export
phyloseq_write_dataset_biom <- function(ps,
                                        filePATH,
                                        filePREFIX,
                                        writeFASTA = TRUE,
                                        rename = FALSE,
                                        useREFSEQ = TRUE) {
  #pull seqs from refseq slot or extract from ASV ID for fasta format
  if (isTRUE(useREFSEQ)) {
    #from phyloseq refseq slot
    f.onames <- phyloseq::refseq(ps)
  } else {
    f.onames <- phyloseq::taxa_names(ps)
  }
  if (isTRUE(rename)) {
    phyloseq::taxa_names(ps) <-
      paste("ASV", 1:length(phyloseq::taxa_names(ps)), sep = "")
    names(f.onames) <- paste0(">", phyloseq::taxa_names(ps))
  } else {
    names(f.onames) <- paste0(">", phyloseq::taxa_names(ps))
  }
  #generate biom file
  suppressWarnings(
    ps.b <- biomformat::make_biom(
      data = .format_asv_table(ps),
      sample_metadata = as.data.frame(phyloseq::sample_data(ps)),
      observation_metadata = as.data.frame(phyloseq::tax_table(ps)),
      matrix_element_type = "int"
    )
  )
  #create output string
  if (isTRUE(writeFASTA)) {
    fa <- print(paste0(filePATH, filePREFIX, "_asv.fasta"))
  }
  bo <- print(paste0(filePATH, filePREFIX, "_asv_table.biom"))
  #write output
  if (isTRUE(writeFASTA)) {
    write.table(
      x = f.onames,
      file = fa,
      quote = FALSE,
      sep = "\n",
      col.names = FALSE
    )
  }
  #biom export
  biomformat::write_biom(x = ps.b, biom_file = bo)
  #return phyloseq object with taxa renamed to ASV1, etc., if desired
  if (isTRUE(rename)) {
    return(ps)
  }
}

#' Formats the sequence table from a phyloseq object
#' @description Formats the sequence table from a phyloseq object to a matrix
#' for export to other formats.
#' @keywords internal
.format_asv_table <- function(ps) {
  if (as.logical(class(phyloseq::otu_table(ps))[1] == "otu_table") &&
      as.logical(taxa_are_rows(phyloseq::otu_table(ps)) == TRUE)) {
    asv.tab <- as.matrix(phyloseq::otu_table(ps))
  } else {
    asv.tab <- as.matrix(t(phyloseq::otu_table(ps)))
  }
  return(asv.tab)
}

#'@title Pairwise multilevel comparison using adonis
#'
#'@description This is a wrapper function for multilevel pairwise comparison
#' using adonis() from package 'vegan'. The function returns adjusted p-values using p.adjust().
#'
#'@param x Data frame (the community table), or "dist" object (user-supplied distance matrix).
#'
#'@param factors Vector (a column or vector with the levels to be compared pairwise).
#'
#'@param sim.function Function used to calculate the similarity matrix,
#' one of 'daisy' or 'vegdist' default is 'vegdist'. Ignored if x is a distance matrix.
#'
#'@param sim.method Similarity method from daisy or vegdist, default is 'bray'. Ignored if x is a distance matrix.
#'
#'@param p.adjust.m The p.value correction method, one of the methods supported by p.adjust(),
#' default is 'bonferroni'.
#'
#'@param reduce String. Restrict comparison to pairs including these factors. If more than one factor, separate by pipes like  reduce = 'setosa|versicolor'
#'
#'@param perm The number of permutations.
#'
#'@return Table with the pairwise factors, Df, SumsOfSqs, F-values, R^2, p.value and adjusted p.value.
#'
#'@author Pedro Martinez Arbizu & Sylvain Monteux
#'
#'@examples
#' data(iris)
#' pairwise_adonis(iris[,1:4],iris$Species)
#'
#'
#'#similarity euclidean from vegdist and holm correction
#' pairwise_adonis(x=iris[,1:4],factors=iris$Species,sim.function='vegdist',
#' sim.method='euclidian',p.adjust.m='holm')
#'
#'#identical example using a distance matrix as an input
#' dist_matrix=vegdist(iris[,1:4],method="euclidean")
#' pairwise_adonis(dist_matrix,factors=iris$Species,
#' p.adjust.m='holm')
#'
#'#similarity manhattan from daisy and bonferroni correction
#' pairwise_adonis(x=iris[,1:4],factors=iris$Species,sim.function='daisy',
#' sim.method='manhattan',p.adjust.m='bonferroni')
#'
#'#Restrict comparison to only some factors
#'pairwise_adonis(iris[,1:4],iris$Species, reduce='setosa')
#'
#'#for more than one factor separate by pipes
#'pairwise_adonis(iris[,1:4],iris$Species, reduce='setosa|versicolor')
#'
#'
#'@export pairwise_adonis
#'@importFrom stats p.adjust
#'@importFrom utils combn
#'@importFrom vegan adonis adonis2 vegdist
#'@importFrom cluster daisy
pairwise_adonis <- function(x,factors, sim.function = 'vegdist', sim.method = 'bray', p.adjust.m ='bonferroni',reduce=NULL,perm=999)
{

  co <- combn(unique(as.character(factors)),2)
  pairs <- c()
  Df <- c()
  SumsOfSqs <- c()
  F.Model <- c()
  R2 <- c()
  p.value <- c()


  for(elem in 1:ncol(co)){
    if(inherits(x, 'dist')){
      x1=as.matrix(x)[factors %in% c(as.character(co[1,elem]),as.character(co[2,elem])),
                      factors %in% c(as.character(co[1,elem]),as.character(co[2,elem]))]
      }

    else  (
      if (sim.function == 'daisy'){
            x1 = daisy(x[factors %in% c(co[1,elem],co[2,elem]),],metric=sim.method)
        }
      else{x1 = vegdist(x[factors %in% c(co[1,elem],co[2,elem]),],method=sim.method)}
    )

    x2 = data.frame(Fac = factors[factors %in% c(co[1,elem],co[2,elem])])

    ad <- adonis2(x1 ~ Fac, data = x2,
                 permutations = perm);
    pairs <- c(pairs,paste(co[1,elem],'vs',co[2,elem]));
    Df <- c(Df,ad$Df[1])
	SumsOfSqs <- c(SumsOfSqs,ad$SumOfSqs[1])
	F.Model <- c(F.Model,ad$F[1]);
    R2 <- c(R2,ad$R2[1]);
    p.value <- c(p.value,ad$`Pr(>F)`[1])
  }
  p.adjusted <- p.adjust(p.value,method=p.adjust.m)

  sig = c(rep('',length(p.adjusted)))
  sig[p.adjusted <= 0.05] <-'.'
  sig[p.adjusted <= 0.01] <-'*'
  sig[p.adjusted <= 0.001] <-'**'
  sig[p.adjusted <= 0.0001] <-'***'
  pairw.res <- data.frame(pairs,Df,SumsOfSqs,F.Model,R2,p.value,p.adjusted,sig)

  if(!is.null(reduce)){
    pairw.res <- subset (pairw.res, grepl(reduce,pairs))
    pairw.res$p.adjusted <- p.adjust(pairw.res$p.value,method=p.adjust.m)

    sig = c(rep('',length(pairw.res$p.adjusted)))
 	sig[pairw.res$p.adjusted <= 0.1] <-'.'
	sig[pairw.res$p.adjusted <= 0.05] <-'*'
	sig[pairw.res$p.adjusted <= 0.01] <-'**'
	sig[pairw.res$p.adjusted <= 0.001] <-'***'
    pairw.res <- data.frame(pairw.res[,1:7],sig)
  }
  class(pairw.res) <- c("pwadonis", "data.frame")
  return(pairw.res)
}
