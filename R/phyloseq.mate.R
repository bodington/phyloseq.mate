#' Cluster ASVs in a sequence table into OTUs
#
#' @description
#' Takes the ASV sequence table generated by DADA2 (seqtab) or phyloseq and
#' clusters OTUs.
#'
#' @details Filler
#' @param seqtab A sequence table eg. generated by dada2.
#' @param similarity OTU clustering distance (%).
#' @param nproc Number of processors.
#' @return A clustered sequence table
#' @importFrom Biostrings DNAStringSet
#' @importFrom DECIPHER AlignSeqs
#' @importFrom DECIPHER TreeLine
#' @examples
#' \dontrun{
#' clustered.seqtab <- cluster_asv_dada2(asv.seqtab)
#' }
#' @export
cluster_asv_dada2 <- function(seqtab,
                              similarity = 99,
                              nproc = 4) {
  asv_sequences <- colnames(seqtab)
  dna <- Biostrings::DNAStringSet(asv_sequences)
  aln <- DECIPHER::AlignSeqs(dna, processors = nproc)
  d <- DECIPHER::DistanceMatrix(aln, processors = nproc)
  clusters <- DECIPHER::TreeLine(
    myDistMatrix = d,
    method = "complete",
    cutoff = 1 - similarity / 100,
    type = "clusters",
    processors = nproc
  )
  clusters <- clusters %>%
    add_column(sequence = asv_sequences)
  seqtab_clustered <- seqtab %>%
    t %>%
    rowsum(clusters$cluster) %>%
    t
  return(seqtab_clustered)
}


#' Cluster ASVs in a phyloseq object into OTUs
#'
#' @description
#' Takes a phyloseq object with sequence data and clusters ASVs to OTUs
#'
#' @param ps A phyloseq object
#' @param similarity OTU clustering distance (%)
#' @param nproc Number of processors
#'
#' @details Filler
#' @return A phyloseq object with OTUs at a set similarity
#' @importFrom phyloseq refseq
#' @importFrom DECIPHER AlignSeqs
#' @importFrom DECIPHER TreeLine
#' @importFrom speedyseq merge_taxa_vec
#' @examples
#' \dontrun{
#' clustered.seqtab <- cluster_asv_dada2(asv.seqtab)
#' }
#' @export
cluster_asv_phyloseq <- function(ps,
                                 similarity = 99,
                                 nproc = 4) {
  dna <- refseq(ps)
  aln <- DECIPHER::AlignSeqs(dna, processors = nproc)
  d <- DECIPHER::DistanceMatrix(aln, processors = nproc)
  clusters <- DECIPHER::TreeLine(
    myDistMatrix = d,
    method = "complete",
    cutoff = 1 - similarity / 100,
    type = "clusters",
    processors = nproc
  )
  ps <-
    speedyseq::merge_taxa_vec(ps, group = clusters$cluster, tax_adjust = 2)
  taxa_names(ps) <- paste0("OTU", seq(ntaxa(ps)))
  return(ps)
}

#' Classify a phyloseq object with dada2
#'
#' @description
#' Assigns taxonomy to a phyloseq object using dada2 assignTaxonomy
#'
#' @param ps A phyloseq object
#' @details The sequence table is assigned taxonomy using assignTaxonomy with
#' @details the greengenes or GTDB training set. (Ranks: D;P;C;O;F;G;S)
#' @return A phyloseq object with new tax assignments added to the tax table.
#' @import phyloseq
#' @importFrom dada2 assignTaxonomy
#' @examples
#' \dontrun{
#' tax_table(phyloseq_project) <- phyloseq_tax_dada2(phyloseq_project, tax_file)
#' }
#' @export
phyloseq_tax_dada2 <- function(ps,
                               tax_file) {
  taxid <- assignTaxonomy(
    seqs = refseq(ps),
    refFasta = tax_file,
    minBoot = 80,
    multithread = TRUE
  )
  rownames(taxid) <- names(rownames(taxid))
  ps <- merge_phyloseq(ps, tax_table(taxid))
  return(ps)
}

#' Classify a phyloseq object with decipher
#'
#' @description
#' Assigns taxonomy to a phyloseq object using decipher, and returns the tax table
#'
#' @param ps A phyloseq object
#' @details The sequence table is assigned taxonomy using DECIPHER with the
#' @details greengenes or GTDB training set. (Ranks: D;P;C;O;F;G;S)
#' @return A phyloseq object with new tax assignments merged into the tax table.
#' @import phyloseq
#' @importFrom DECIPHER IdTaxa
#' @examples
#' \dontrun{
#' tax_table(phyloseq_project) <- phyloseq_decipher_tax(phyloseq_project, tax_file)
#' }
#' @export
phyloseq_tax_decipher <- function(ps,
                                  tax_file,
                                  nprocs = 8) {
  load(tax_file)
  dna <- refseq(ps)
  ids <- IdTaxa(dna,
    trainingSet,
    strand = "top",
    processors = nprocs,
    verbose = FALSE
  )
  ranks <- c("domain", "phylum", "class", "order", "family", "genus", "species")
  taxid <- t(
    sapply(
      ids,
      function(x) {
        m <- match(ranks, x$rank)
        taxa <- x$taxon[m]
        taxa[startsWith(taxa, "unclassified_")] <- NA
        taxa
      }
    )
  )
  colnames(taxid) <- ranks
  rownames(taxid) <- names(dna)
  ps <- merge_phyloseq(ps, tax_table(taxid))
  return(ps)
}

#' Cleanly merge (using sequence as ASV name) phyloseq objects in a list
#'
#' @description
#' Assigns taxonomy to a phyloseq object using decipher, and returns the tax
#' table
#'
#' @param ps_list A list of phyloseq objects
#' @details A list containing only phyloseq objects can be cleanly merged,
#' @details including identical ASVs where the ASV name differs in the objects.
#' @details ASV merging is done by sequence
#' @return A phyloseq object with all objects in the list merged
#' @import phyloseq
#' @examples
#' \dontrun{
#' merged_phyloseq <- phyloseq_clean_merge(list_of_phyloseq_objects)
#' }
#' @export
phyloseq_clean_merge <- function(phyloseq_list) {
  do.call(
    merge_phyloseq,
    lapply(
      phyloseq_list,
      function(x) {
        taxa_names(x) <- as.character(refseq(x), use.names = FALSE)
        return(x)
      }
    )
  )
}


#' Root Tree in phyloseq Object
#'
#' @description
#' Roots an unrooted tree in a phyloseq object
#'
#' @param ps A phyloseq object containing an unrooted tree
#' @details The tree is rooted by the longest terminal branch.
#' @return The same phyloseq object with a rooted tree
#' @importFrom ape Ntip
#' @importFrom magrittr %>%
#' @importFrom data.table data.table
#' @examples
#' \dontrun{
#' expt.rooted <- root_phyloseq_tree(expt.unrooted)
#' }
#' @export
phyloseq_root_tree <- function(ps) {
  tree.unrooted <- phy_tree(ps)
  # tablify parts of tree that we need.
  treeDT <-
    cbind(
      data.table(tree.unrooted$edge),
      data.table(length = tree.unrooted$edge.length)
    )[1:Ntip(tree.unrooted)] %>%
    cbind(data.table(id = tree.unrooted$tip.label))
  # Take the longest terminal branch as outgroup
  new.outgroup <- treeDT[which.max(length)]$id
  new.tree <- ape::root(tree.unrooted, outgroup = new.outgroup, resolve.root = TRUE)
  phy_tree(ps) <- new.tree
  return(ps)
}

#' Split Pseudomonadota
#'
#' @description
#' Splits Pseudomonadota into the Proteobacteria classes
#'
#' @param ps A phyloseq object
#' @details The tax table is returned with Pseudomonadota split into the
#' @details Proteobacteria classes
#' @return The same phyloseq object with Proteobacteria classes in the "Phylum"
#' @return column.
#' @import phyloseq
#' @examples
#' \dontrun{
#' phyloseq_object_proteo <- phyloseq_split_proteo(phyloseq_object)
#' }
#' @export
phyloseq_split_proteo <- function(ps) {
  plot.tax <- as.data.frame(
    ps@tax_table
  )
  plot.tax <- data.frame(
    lapply(
      plot.tax,
      as.character
    ),
    stringsAsFactors = FALSE
  )
  plot.tax$Phylum[plot.tax$Phylum == "Pseudomonadota"] <- plot.tax$Class[plot.tax$Phylum == "Pseudomonadota"]
  plot.tax[] <- lapply(plot.tax, factor)
  plot.tax.table <- tax_table(plot.tax)
  rownames(plot.tax.table) <- rownames(ps@tax_table)
  colnames(plot.tax.table) <- colnames(ps@tax_table)
  ps@tax_table <- plot.tax.table
  return(ps)
}

#' Export phyloseq object to dataset
#'
#' @description
#' Exports the sequence table and fasta file from a phyloseq object
#'
#' @param ps A phyloseq object
#' @param filePATH The path to write the files
#' @param filePREFIX The prefix for the output files
#' @param writeFASTA Write the fasta file
#' @param rename Rename the ASVs to ASV1, ASV2, etc.
#' @param useREFSEQ Use the refseq slot for sequence data
#' @details A sequence table and fasta file are written to the file path
#' @export
phyloseq_write_dataset <- function(ps,
                                    filePATH,
                                    filePREFIX,
                                    writeFASTA = TRUE,
                                    rename = FALSE,
                                    useREFSEQ = TRUE) {
  #pull seqs from refseq slot or extract from ASV ID for fasta format
  if (isTRUE(useREFSEQ)) {
    #from phyloseq refseq slot
    f.onames <- phyloseq::refseq(ps)
  } else {
    f.onames <- phyloseq::taxa_names(ps)
  }
  if (isTRUE(rename)) {
    phyloseq::taxa_names(ps) <-
      paste("ASV", 1:length(phyloseq::taxa_names(ps)), sep = "")
    names(f.onames) <- paste0(">", phyloseq::taxa_names(ps))
  } else {
    names(f.onames) <- paste0(">", phyloseq::taxa_names(ps))
  }
  #generate asv table formatted for biom generation
  asv_tab <- format_asv_table(ps)
  suppressWarnings(asv_tab <- as.matrix(asv_tab))
  cb <- as.matrix(cbind(rownames(asv_tab), asv_tab))
  rcb <- as.matrix(rbind(colnames(cb), cb))
  rcb[1, 1] <- "#ASVID"
  rownames(rcb) <- NULL
  colnames(rcb) <- NULL
  #generate tax table formatted for biom generation
  tax.tab <- as.data.frame(phyloseq::tax_table(ps))
  tax.tab$taxonomy <-
    tidyr::unite(tax.tab, "out", c(colnames(tax.tab)), sep = ";")
  cbt <- as.matrix(cbind(rownames(tax.tab), tax.tab$taxonomy))
  rcbt <- as.matrix(rbind(c("#ASVID", "taxonomy"), cbt))
  rownames(cbt) <- NULL
  colnames(cbt) <- NULL
  #generate sampledf table formatted for biom generation
  samdf <- suppressWarnings(as.matrix(phyloseq::sample_data(ps)))
  cbs <- as.matrix(cbind(rownames(samdf), samdf))
  rcbs <- as.matrix(rbind(colnames(cbs), cbs))
  rcbs[1, 1] <- "#SampleID"
  rownames(rcbs) <- NULL
  colnames(rcbs) <- NULL
  #create output string
  if (isTRUE(writeFASTA)) {
    fa <- print(paste0(filePATH, filePREFIX, "_ASVs.fasta"))
  }
  otb <- print(paste0(filePATH, filePREFIX, "_ASV_table.txt"))
  ttb <- print(paste0(filePATH, filePREFIX, "_ASV_taxonomy.txt"))
  stb <- print(paste0(filePATH, filePREFIX, "_sample_data.txt"))
  #write output
  #ASV fasta
  if (isTRUE(writeFASTA)) {
    write.table(
      x = f.onames,
      file = fa,
      quote = FALSE,
      sep = "\n",
      col.names = FALSE
    )
  }
  #asv_tab
  write.table(
    x = rcb,
    file = otb,
    row.names = FALSE,
    col.names = FALSE,
    quote = FALSE,
    sep = "\t"
  )
  #tax.tab
  write.table(
    x = rcbt,
    file = ttb,
    row.names = FALSE,
    col.names = FALSE,
    quote = FALSE,
    sep = "\t"
  )
  #sampledf
  write.table(
    x = rcbs,
    file = stb,
    row.names = FALSE,
    col.names = FALSE,
    quote = FALSE,
    sep = "\t"
  )
  #return phyloseq object with taxa renamed to ASV1, etc., if desired
  if (isTRUE(rename)) {
    return(ps)
  }
}

#' Export phyloseq object to .biom file
#'
#' @description
#' Exports the sequence table and sequences from a phyloseq object
#' to a .biom file
#' @param ps A phyloseq object
#' @param filePATH The path to write the files
#' @param filePREFIX The prefix for the output files
#' @param writeFASTA Write the fasta file
#' @param rename Rename the ASVs to ASV1, ASV2, etc.
#' @param useREFSEQ Use the refseq slot for sequence data
#' @details A sequence table and fasta file are written to the file path
#' @export
phyloseq_write_dataset_biom <- function(ps,
                                        filePATH,
                                        filePREFIX,
                                        writeFASTA = TRUE,
                                        rename = FALSE,
                                        useREFSEQ = TRUE) {
  #pull seqs from refseq slot or extract from ASV ID for fasta format
  if (isTRUE(useREFSEQ)) {
    #from phyloseq refseq slot
    f.onames <- phyloseq::refseq(ps)
  } else {
    f.onames <- phyloseq::taxa_names(ps)
  }
  if (isTRUE(rename)) {
    phyloseq::taxa_names(ps) <-
      paste("ASV", 1:length(phyloseq::taxa_names(ps)), sep = "")
    names(f.onames) <- paste0(">", phyloseq::taxa_names(ps))
  } else {
    names(f.onames) <- paste0(">", phyloseq::taxa_names(ps))
  }
  #generate biom file
  suppressWarnings(
    ps.b <- biomformat::make_biom(
      data = format_asv_table(ps),
      sample_metadata = as.data.frame(phyloseq::sample_data(ps)),
      observation_metadata = as.data.frame(phyloseq::tax_table(ps)),
      matrix_element_type = "int"
    )
  )
  #create output string
  if (isTRUE(writeFASTA)) {
    fa <- print(paste0(filePATH, filePREFIX, "_ASVs.fasta"))
  }
  bo <- print(paste0(filePATH, filePREFIX, "_ASV_table.biom"))
  #write output
  if (isTRUE(writeFASTA)) {
    write.table(
      x = f.onames,
      file = fa,
      quote = FALSE,
      sep = "\n",
      col.names = FALSE
    )
  }
  #biom export
  biomformat::write_biom(x = ps.b, biom_file = bo)
  #return phyloseq object with taxa renamed to ASV1, etc., if desired
  if (isTRUE(rename)) {
    return(ps)
  }
}

#' Formats the sequence table from a phyloseq object
format_asv_table <- function(ps) {
  if (as.logical(class(phyloseq::otu_table(ps))[1] == "otu_table") &&
      as.logical(taxa_are_rows(phyloseq::otu_table(ps)) == TRUE)) {
    asv_tab <- as.matrix(phyloseq::otu_table(ps))
  } else {
    asv_tab <- as.matrix(t(phyloseq::otu_table(ps)))
  }
  return(asv_tab)
}

#' Replace missing taxonomy in a phyloseq object
phyloseq_taxonomy_imputation <- function(ps,
                                         unknown_taxon = "_unidentified",
                                         unknown_sp = " sp",
                                         make_unique = FALSE,
                                         addmaxrank = FALSE) {
  ## If input is of class 'phyloseq'
  inp_class <- class(ps)
  if ("phyloseq" %in% inp_class || "taxonomyTable" %in% inp_class) {
    if (is.null(phyloseq::tax_table(ps, errorIfNULL = F))) {
      stop("Error: taxonomy table slot is empty in the input data.\n")
    }
    x <-
      as.data.frame(phyloseq::tax_table(ps), stringsAsFactors = F)
  } else {
    stop("Error: input data should be of class `phyloseq` or `taxonomyTable`")
  }
  ## Function to replace NAs with higher taxa names + unident string
  replace_col <- function(x,
                          col_num = 2,
                          unident = "unidentified") {
    nas <- is.na(x[, col_num])
    if (any(nas) == FALSE) {
      return(x)              # no missing values
    } else {
      ## which values to replace
      to_repl <- which(nas)
      if (col_num == 1) {
        x[to_repl, col_num] <- unident
      } else {
        x[to_repl, col_num] <-
          paste(x[to_repl, col_num - 1], unident, sep = "")
      }
      return(x)
    }
  }
  clz <- colnames(x)
  sp_in_ranks <- clz %in% c("Species", "species", "sp")
  if (any(sp_in_ranks)) {
    sp_id <- which(sp_in_ranks)
    non_sp_id <- (1:length(clz))[-sp_id]
  } else {
    sp_id <- NA
    non_sp_id <- 1:length(clz)
  }
  ## Replace higher taxa
  for (i in non_sp_id) {
    x <- replace_col(x, col_num = i, unident = unknown_taxon)
  }
  ## Replace species names
  if (!is.na(sp_id)) {
    x <- replace_col(x, col_num = sp_id, unident = unknown_sp)
  }
  ## Function to remove multiple unident strings
  replace_unidents <-
    function(tt, strr = "_unidentified", spp = " sp") {
      ## tt = character vector
      ## Prepare regex for paterns
      # Multiple string occurrences
      multpatt <- paste("(", strr, ")(\\1+)", sep = "")
      unsp <- paste(strr, spp, sep = "")
      rez <-
        gsub(
          x = tt,
          pattern = multpatt,
          replacement = strr,
          perl = T
        )
      ## Replace "_unidetified sp" with " sp"
      rez <-
        gsub(
          x = rez,
          pattern = unsp,
          replacement = spp,
          perl = T
        )
      return(rez)
    }
  ## Remove multiple unident strings from all tax columns
  x <- sapply(x, replace_unidents)
  ## Make species names unique
  if (make_unique == TRUE) {
    x[, ncol(x)] <- base::make.unique(names = x[, ncol(x)], sep = ".")
  }
  ## Add the OTU classification at the lowest annotated taxonomic rank
  if (addmaxrank == TRUE) {
    LowestTaxRank <-
      as.character(get_max_taxonomic_rank(ps, return_rank_only = TRUE))
    x <- cbind(x, LowestTaxRank = LowestTaxRank)
  }
  ## Add taxa names
  rownames(x) <- phyloseq::taxa_names(ps)
  ## Replace tax_table with the modified one
  phyloseq::tax_table(ps) <- phyloseq::tax_table(as.matrix(x))
  return(ps)
}